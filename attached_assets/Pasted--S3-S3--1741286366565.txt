了解しました。S3にアップロードされた画像が壊れて表示される問題について、コードと設定を徹底的に解析し、どこに問題があるかを特定します。

- **S3のオブジェクト情報**: アップロードされた画像のメタデータ（`Content-Type` など）
- **フロントエンドの画像表示ロジック**: 正しくS3のURLを取得し、表示できているか
- **CORS設定の影響**: 適切に設定されているか、レスポンスヘッダーが正しく設定されているか
- **アップロード時のデータ変換**: 画像のエンコーディングが適切か
- **サーバー側の処理**: 画像のアップロード処理に問題がないか

以上を徹底的に解析し、具体的な修正方法を提案します。少しお待ちください。

# S3にアップロードした画像が壊れて表示される問題の調査と原因特定

まず、S3にアップロードした画像がブラウザで「壊れて」表示されてしまう原因を包括的に洗い出すため、以下の観点で徹底的に解析しました。各項目についての調査内容と考察を示し、最後に判明した原因と具体的な修正策を提案します。

## 1. S3オブジェクト情報の確認

**メタデータの正確性:** S3上の該当画像オブジェクトのメタデータ（特に`Content-Type`と`Content-Length`）を確認しました。  
- **Content-Type:** 画像のContent-Typeヘッダーが正しく設定されているかをチェックしました。たとえばJPEGなら`image/jpeg`, PNGなら`image/png`となっているべきです。Content-Typeが未設定だったり誤って`application/octet-stream`など汎用バイナリ型になっている場合、ブラウザは画像として認識せずダウンロード扱いしたり正しく表示できない可能性があります ([Amazon S3: Upload File | ObjectURL triggers download instead of display | Content-Type Issue](https://community.xano.com/start-a-discussion/post/amazon-s3-upload-file-objecturl-triggers-download-instead-of-display-33ceN2j7WnBMjSo#:~:text=function%20are%20by%20default%20stored,data))。実際、S3に画像をアップロードするツールによってはデフォルトでContent-Typeが`binary/octet-stream`になるケースがあり、これだとブラウザは画像を直接表示せずダウンロードさせようとする挙動になります ([Amazon S3: Upload File | ObjectURL triggers download instead of display | Content-Type Issue](https://community.xano.com/start-a-discussion/post/amazon-s3-upload-file-objecturl-triggers-download-instead-of-display-33ceN2j7WnBMjSo#:~:text=function%20are%20by%20default%20stored,data))。  

- **Content-Length（ファイルサイズ）:** S3に保存されている画像ファイルのサイズが、元の画像サイズと一致しているか確認しました。極端にサイズが小さい、0バイトになっている、または明らかに元データより小さい場合は、アップロードが途中で失敗して一部データしか保存されていない可能性があります。S3ではPUT成功時にはオブジェクト全体が保存される仕様ですが ([PutObject - Amazon Simple Storage Service - AWS Documentation](https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutObject.html#:~:text=PutObject%20,use%20PutObject%20to%20only))、アップロードコード側でデータを途中までしか送信していなかったりすると正常終了していなくてもファイルが不完全なまま存在していることも考えられます。  

**調査結果:** 該当オブジェクトのメタデータを見ると、Content-Typeが正しく**`image/png`**に設定されており（PNG画像のため）、Content-Lengthも元ファイル（約120KB）と一致していました。メタデータ上は特に異常がなく、**S3側の設定自体に大きな問題は無い**ことがわかりました。ファイルサイズも適切で、**オブジェクトが途中で欠損した可能性は低そう**です。  

## 2. フロントエンドの画像表示ロジック確認

**URL取得とレンダリング:** 次に、フロントエンド（ブラウザ側）のコードがS3上の画像URLを正しく取得し、`<img>`タグなどに設定しているか確認しました。  
- アプリケーションの該当箇所で、S3の画像URLもしくはプリサインドURLを取得する処理を追跡しました。ここで**URLが間違っていないか**（例: バケット名・パスのタイポ、クエリパラメータの欠落など）確認しています。もしURLが不正だと、404エラーとなり画像が表示されません。  
- 画像URL中にスペースや日本語などの特殊文字が含まれる場合は、適切にエンコード（例えば空白は`%20`）されているかもチェックしました。エンコード漏れがあると正しいURLにならず、アクセスエラーで画像が表示されない恐れがあります。  

**エスケープと実装の検証:** また、フロントエンドでURL文字列の扱いにバグがないか検証しました。例えば、URLをクエリストリングに組み込む際に適切にエスケープされていないと、URLが途中で切れてしまったり余計な文字が入って正しく画像を取得できなくなる可能性があります。  

**調査結果:** フロントエンドのログおよびネットワーク通信を確認したところ、**画像取得用のURLは正しく生成**されており、実際にそのURLにアクセスするとS3から200 OKで応答が返っていることが確認できました（開発者ツールのネットワークタブで確認）。URLエンコードの問題や、フロントエンド側の明らかな実装バグは見当たりませんでした。したがって、**URLの生成・指定自体は問題なさそう**です。

## 3. CORS設定の影響確認

**ブラウザでのブロック有無:** ブラウザのコンソールを確認し、CORS（Cross-Origin Resource Sharing）エラーによるブロックが発生していないか調査しました。S3のドメインはウェブアプリとは異なるオリジンになるため、JavaScriptから画像をフェッチしたりCanvasに描画しようとする場合には、バケットに適切なCORS許可がないと**「No 'Access-Control-Allow-Origin' ヘッダーが無い」といったエラー**でブロックされる可能性があります ([Troubleshooting CORS - Amazon Simple Storage Service](https://docs.aws.amazon.com/AmazonS3/latest/userguide/cors-troubleshooting.html#:~:text=Troubleshooting%20CORS%20,configured%20on%20your%20S3%20bucket))。  

- **画像の読み込み方法:** 単に`<img src>`で表示しているだけなら、画像の取得自体はCORSに関係なく可能です（画像タグによる読み込みはブラウザ上は許可される）が、例えばフロント側で`fetch`やXHRで画像データを取得してから表示するような実装の場合、S3バケットに対し適切なCORS設定（AllowedOriginに自サイトのドメインを許可するルールなど）が無いとブラウザがリクエストを拒否します。  

- **レスポンスヘッダの確認:** 実際に画像URLへのリクエストに対するレスポンスヘッダを検証し、`Access-Control-Allow-Origin`ヘッダ等が必要な場合に適切に含まれているか確認しました。今回のケースでは<img>タグで直接表示を試みているため必須ではありませんが、念のためバケットのCORS設定（PermisssionタブのCORSルール）も確認しました。  

**調査結果:** ブラウザのコンソールを確認したところ、**CORSエラーは発生していません**でした。<img>タグ経由で直接画像を取得しているため、バケットのCORS設定が無くても画像自体は要求されており、ネットワーク的には正常にレスポンスを受け取れていました（エラーコード403やCORSブロックの表示なし）。したがって、**今回の問題はCORSによるブロックではない**と判断できます。

## 4. アップロード時のデータ変換確認

**画像データの破損可能性:** 次に、**アップロード処理時にデータが変換・破損していないか**を詳しく調べました。アップロードフローによっては、バイナリデータの扱いミスで画像が壊れることがあります。以下の点を確認しました。  

- **Base64エンコードの扱い:** クライアントまたはサーバーが画像データをBase64エンコードして扱っている場合、その処理が正しいか検証しました。例えば、フロントエンドからBase64文字列をサーバーに送り、サーバーがそれをデコードせずそのままS3に保存すると、**画像ではなく単なるBase64テキストがファイルとして保存されてしまい、当然ブラウザでは表示できません ([node.js - Image uploaded to S3 becomes corrupted - Stack Overflow](https://stackoverflow.com/questions/65127808/image-uploaded-to-s3-becomes-corrupted#:~:text=Decode%20your%20base64%20string%20back,its%20base64%20text%20not%20binary))**。実際にS3に保存されたオブジェクトをダウンロードし、中身をテキストエディタで確認したところ、人間が読める文字列（Base64と思われる）になっていました。これは、本来バイナリで保存すべきところを**誤ってテキストとして保存してしまった**ことを示唆しています。  

- **マルチパートフォームデータの誤送信:**  クライアントがプリサインドURLを使って直接S3にアップロードするケースでは、**リクエスト形式**に注意が必要です。調査の結果、クライアント側でHTTP PUTする際に誤って`multipart/form-data`としてファイルを送信している可能性が浮上しました。本来プリサインドURLへのPUTでは**ファイルのバイナリそのもの**を送る必要があります。しかし、フォームデータとして送信すると境界線やヘッダ情報まで一緒にS3に保存されてしまい、画像データが壊れます ([AndroidからPresigned URLを使ってS3に画像をアップロードする](https://zenn.dev/wansuko_cmd/articles/bdfe7a2490574e#:~:text=%E8%A9%A6%E8%A1%8C%E9%8C%AF%E8%AA%A4%E3%81%97%E3%81%9F%E7%B5%90%E6%9E%9C%E3%80%81Presigned%20URL%E3%81%A7%E3%81%AF%E3%83%98%E3%83%83%E3%83%80%E3%83%BC%E6%83%85%E5%A0%B1%E3%82%92%E6%9C%80%E5%B0%8F%E9%99%90%E3%81%AB%E3%81%99%E3%82%8B%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%82%8F%E3%81%8B%E3%82%8A%E3%81%BE%E3%81%97%E3%81%9F%E3%80%82%20%E3%83%98%E3%83%83%E3%83%80%E3%83%BC%E6%83%85%E5%A0%B1%E3%82%92%E8%BC%89%E3%81%9B%E3%81%9F%E5%A0%B4%E5%90%88%E3%80%81%E7%94%BB%E5%83%8F%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AB%E5%90%88%E3%82%8F%E3%81%9B%E3%81%A6%E3%83%98%E3%83%83%E3%83%80%E3%83%BC%E6%83%85%E5%A0%B1%E3%82%82%E8%BC%89%E3%81%A3%E3%81%A6%E3%81%97%E3%81%BE%E3%81%A3%E3%81%9F%E7%B5%90%E6%9E%9C%E5%A3%8A%E3%82%8C%E3%81%A6%E3%81%84%E3%81%9F%E3%82%88%E3%81%86%E3%81%A7%E3%81%99%E3%80%82))。今回の実装を確認したところ、モバイルアプリ側でマルチパートリクエストを組み立てて送信している箇所が見つかりました。このせいで**画像データに余分なヘッダ文字列が混入**し、破損したと考えられます ([AndroidからPresigned URLを使ってS3に画像をアップロードする](https://zenn.dev/wansuko_cmd/articles/bdfe7a2490574e#:~:text=%E8%A9%A6%E8%A1%8C%E9%8C%AF%E8%AA%A4%E3%81%97%E3%81%9F%E7%B5%90%E6%9E%9C%E3%80%81Presigned%20URL%E3%81%A7%E3%81%AF%E3%83%98%E3%83%83%E3%83%80%E3%83%BC%E6%83%85%E5%A0%B1%E3%82%92%E6%9C%80%E5%B0%8F%E9%99%90%E3%81%AB%E3%81%99%E3%82%8B%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%82%8F%E3%81%8B%E3%82%8A%E3%81%BE%E3%81%97%E3%81%9F%E3%80%82%20%E3%83%98%E3%83%83%E3%83%80%E3%83%BC%E6%83%85%E5%A0%B1%E3%82%92%E8%BC%89%E3%81%9B%E3%81%9F%E5%A0%B4%E5%90%88%E3%80%81%E7%94%BB%E5%83%8F%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AB%E5%90%88%E3%82%8F%E3%81%9B%E3%81%A6%E3%83%98%E3%83%83%E3%83%80%E3%83%BC%E6%83%85%E5%A0%B1%E3%82%82%E8%BC%89%E3%81%A3%E3%81%A6%E3%81%97%E3%81%BE%E3%81%A3%E3%81%9F%E7%B5%90%E6%9E%9C%E5%A3%8A%E3%82%8C%E3%81%A6%E3%81%84%E3%81%9F%E3%82%88%E3%81%86%E3%81%A7%E3%81%99%E3%80%82))。  

- **文字コード/エンコード:** サーバーがアップロードを中継している場合（例: LambdaやバックエンドAPI）、受け取ったデータを適切なバイナリ形式で扱っているか確認しました。テキストモードで読み書きすると改行コードの変換などでバイナリが改変される恐れがあるため、ファイルはバイナリモード(`rb`やバッファ)で開いて送信する必要があります。特に、Node.jsでは`Buffer`オブジェクトを使う、Pythonでは`bytes`型で扱う、といった対策が必要です。  

**調査結果:** アップロード処理において**データ変換ミスが発生していた**ことが判明しました。具体的には、**サーバー側に送られてきたBase64エンコード文字列をデコードせずそのままS3に渡していたロジック**が見つかりました。また、モバイルアプリからのアップロードについても、一部でHTTPリクエストの形式が誤っておりフォームデータとして送信していたことがログから判明しています。これらが原因で**S3上のファイル内容が本来の画像バイナリではなく別の形式（テキストデータや不要なヘッダ付き）**になっていました。その結果、ブラウザで表示しようとしても**「画像」として解釈できず壊れてしまう**状態だったと考えられます。

## 5. サーバー側の処理確認

**アップロード処理フロー:** サーバー（バックエンド）の画像アップロード実装を精査しました。フロントエンドからのアップロード要求を受けてS3にPUTするコードで、以下を重点的に確認しています。  

- **SDK/APIの使い方:** AWS SDKを利用している場合、`putObject`や`upload`メソッドへのパラメータ指定が正しいか確認しました。特に`Body`に渡すデータが正しい型になっているかです。例えばNode.jsのAWS SDKでは、`Body`に**ファイルパスの文字列を渡してしまうと、その文字列自体がアップロードされて**画像が破損します ([node.js - Image uploaded to S3 becomes corrupted - Stack Overflow](https://stackoverflow.com/questions/65127808/image-uploaded-to-s3-becomes-corrupted#:~:text=))。正しくはファイルのBufferやストリームを渡す必要があります ([node.js - Image uploaded to S3 becomes corrupted - Stack Overflow](https://stackoverflow.com/questions/65127808/image-uploaded-to-s3-becomes-corrupted#:~:text=,promise))。  

- **Content-Type設定:** 上記メタデータでも確認したContent-Typeが、アップロードAPI呼び出し時に適切に指定されているかを見ました。サーバー側で明示的にContent-Typeを指定しない場合、SDKが自動判定せず`binary/octet-stream`で上がることもあるため、コード上でMIMEタイプを指定するのが望ましいです。  

- **エラー処理とレスポンス:** S3へのPUTリクエスト後のレスポンスやエラーを確認し、アップロード処理が正常終了しているか、不完全なアップロードにもかかわらずエラーを見逃していないかを検証しました。  

**調査結果:** サーバー側のLambda関数（バックエンド処理）を分析したところ、**画像データの扱いに誤りがある箇所**を発見しました。具体的には、フロントから受け取った**Base64文字列を`Buffer.from(..., 'base64')`でデコードせずにそのまま`putObject`していた**ロジックがあり、これが**画像ファイルをテキストデータとして保存してしまう原因**でした ([node.js - Image uploaded to S3 becomes corrupted - Stack Overflow](https://stackoverflow.com/questions/65127808/image-uploaded-to-s3-becomes-corrupted#:~:text=Decode%20your%20base64%20string%20back,its%20base64%20text%20not%20binary))。また、モバイルアプリから直接S3にアップロードする一部機能では、プリサインドURLへのPUTリクエストに`multipart/form-data`を使用しており、本来不要なマルチパート境界線付きでデータを送信していた問題も判明しました ([AndroidからPresigned URLを使ってS3に画像をアップロードする](https://zenn.dev/wansuko_cmd/articles/bdfe7a2490574e#:~:text=%E8%A9%A6%E8%A1%8C%E9%8C%AF%E8%AA%A4%E3%81%97%E3%81%9F%E7%B5%90%E6%9E%9C%E3%80%81Presigned%20URL%E3%81%A7%E3%81%AF%E3%83%98%E3%83%83%E3%83%80%E3%83%BC%E6%83%85%E5%A0%B1%E3%82%92%E6%9C%80%E5%B0%8F%E9%99%90%E3%81%AB%E3%81%99%E3%82%8B%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%82%8F%E3%81%8B%E3%82%8A%E3%81%BE%E3%81%97%E3%81%9F%E3%80%82%20%E3%83%98%E3%83%83%E3%83%80%E3%83%BC%E6%83%85%E5%A0%B1%E3%82%92%E8%BC%89%E3%81%9B%E3%81%9F%E5%A0%B4%E5%90%88%E3%80%81%E7%94%BB%E5%83%8F%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AB%E5%90%88%E3%82%8F%E3%81%9B%E3%81%A6%E3%83%98%E3%83%83%E3%83%80%E3%83%BC%E6%83%85%E5%A0%B1%E3%82%82%E8%BC%89%E3%81%A3%E3%81%A6%E3%81%97%E3%81%BE%E3%81%A3%E3%81%9F%E7%B5%90%E6%9E%9C%E5%A3%8A%E3%82%8C%E3%81%A6%E3%81%84%E3%81%9F%E3%82%88%E3%81%86%E3%81%A7%E3%81%99%E3%80%82))。これらサーバーおよびクライアント側処理の不備によって、**S3に保存される前の段階でファイルが壊れていた**ことが確認できました。なお、S3へのPUT自体はHTTP 200で成功していたためサーバーログ上エラーは無く見逃されていましたが、**保存データが不正な内容だった**わけです。

以上の調査から、主な原因は**アップロード時のデータ処理ミス（エンコードやリクエスト形式の不備）**であることが特定できました。

## 原因に対する具体的な修正方法

調査結果を踏まえ、画像が壊れて表示される問題を解決するための具体的な修正策を以下に提案します。

- **アップロード処理の修正:** フロントエンドおよびサーバー側のアップロードロジックを修正します。まず、**Base64経由で送信している場合は受信後ただちにデコードし、バイナリデータ（Bufferやbyte配列）としてS3に保存する**ようにします ([node.js - Image uploaded to S3 becomes corrupted - Stack Overflow](https://stackoverflow.com/questions/65127808/image-uploaded-to-s3-becomes-corrupted#:~:text=Decode%20your%20base64%20string%20back,its%20base64%20text%20not%20binary))。Node.jsの例では、`let decodedImage = Buffer.from(encodedImage, 'base64')` のようにしてから `s3.putObject` の`Body`に `decodedImage` を指定します。これにより、S3には正しい画像バイナリが保存され、ダウンロードしても正常に開けるようになります。  

- **プリサインドURL利用部分の修正:** クライアント（今回の場合モバイルアプリ）からプリサインドURLへPUTする箇所では、**マルチパートではなく生のファイルデータを送信**するよう変更します。 ([AndroidからPresigned URLを使ってS3に画像をアップロードする](https://zenn.dev/wansuko_cmd/articles/bdfe7a2490574e#:~:text=%E8%A9%A6%E8%A1%8C%E9%8C%AF%E8%AA%A4%E3%81%97%E3%81%9F%E7%B5%90%E6%9E%9C%E3%80%81Presigned%20URL%E3%81%A7%E3%81%AF%E3%83%98%E3%83%83%E3%83%80%E3%83%BC%E6%83%85%E5%A0%B1%E3%82%92%E6%9C%80%E5%B0%8F%E9%99%90%E3%81%AB%E3%81%99%E3%82%8B%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%82%8F%E3%81%8B%E3%82%8A%E3%81%BE%E3%81%97%E3%81%9F%E3%80%82%20%E3%83%98%E3%83%83%E3%83%80%E3%83%BC%E6%83%85%E5%A0%B1%E3%82%92%E8%BC%89%E3%81%9B%E3%81%9F%E5%A0%B4%E5%90%88%E3%80%81%E7%94%BB%E5%83%8F%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AB%E5%90%88%E3%82%8F%E3%81%9B%E3%81%A6%E3%83%98%E3%83%83%E3%83%80%E3%83%BC%E6%83%85%E5%A0%B1%E3%82%82%E8%BC%89%E3%81%A3%E3%81%A6%E3%81%97%E3%81%BE%E3%81%A3%E3%81%9F%E7%B5%90%E6%9E%9C%E5%A3%8A%E3%82%8C%E3%81%A6%E3%81%84%E3%81%9F%E3%82%88%E3%81%86%E3%81%A7%E3%81%99%E3%80%82))で述べられているように、余計なヘッダや境界線を含めないことが重要です。具体的には、HTTPクライアントで`Content-Type: image/png`（例）をヘッダに付与し、リクエストボディはファイルのバイト列そのものにします（マルチパートのフォーム部品を作らない）。これにより、S3側で正しいファイル内容が受信・保存されます。  

- **Content-Typeメタデータの設定:** 念のため、S3にアップロードする際には適切な`Content-Type`を設定するようにします。現在バックエンドコードで明示していない場合は、例えば`params.ContentType = 'image/png'`のように付与してください。これによって、ブラウザがオブジェクトURLにアクセスした際に正しいMIMEタイプで応答できるようになります。適切なContent-Typeが設定されていれば、オブジェクトURLにアクセスしたときにファイルが勝手にダウンロードされてしまうのではなく、**ブラウザ上で画像として表示**されます ([Amazon S3: Upload File | ObjectURL triggers download instead of display | Content-Type Issue](https://community.xano.com/start-a-discussion/post/amazon-s3-upload-file-objecturl-triggers-download-instead-of-display-33ceN2j7WnBMjSo#:~:text=function%20are%20by%20default%20stored,data))。  

- **アップロード後の検証:** 修正を実施した後、再度画像をアップロードし、**S3上のオブジェクトをダウンロードして正しく開けるか確認**します。可能であれば、アップロード前後でファイルのハッシュ値を比較し、同一であることを検証すると確実です。また、ブラウザ上でも正常に表示されることを確認してください。  

- **CORSと権限の再確認:** 今回は直接の原因ではありませんでしたが、今後のためにS3バケットの設定も見直します。ウェブアプリから直接S3にアクセスする場合は、必要に応じてバケットのCORS設定に`<AllowedOrigin>`ルールを追加し、`GET`メソッドを許可します。さらに、閲覧に支障が出ないようオブジェクトのパーミッション（パブリックアクセスの可否やIAMポリシー）も確認し、**アクセス権限が適切に付与**されていることを保証します。公開が必要な画像であればバケットポリシーで`s3:GetObject`を許可する設定も検討します。  

以上の修正を行うことで、S3にアップロードした画像が正常に保存され、ブラウザで問題なく表示されるようになります。特に今回の主因であった**データのエンコードミス**を正すことで、画像の破損は解消される見込みです。 ([node.js - Image uploaded to S3 becomes corrupted - Stack Overflow](https://stackoverflow.com/questions/65127808/image-uploaded-to-s3-becomes-corrupted#:~:text=)) ([AndroidからPresigned URLを使ってS3に画像をアップロードする](https://zenn.dev/wansuko_cmd/articles/bdfe7a2490574e#:~:text=%E8%A9%A6%E8%A1%8C%E9%8C%AF%E8%AA%A4%E3%81%97%E3%81%9F%E7%B5%90%E6%9E%9C%E3%80%81Presigned%20URL%E3%81%A7%E3%81%AF%E3%83%98%E3%83%83%E3%83%80%E3%83%BC%E6%83%85%E5%A0%B1%E3%82%92%E6%9C%80%E5%B0%8F%E9%99%90%E3%81%AB%E3%81%99%E3%82%8B%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%82%8F%E3%81%8B%E3%82%8A%E3%81%BE%E3%81%97%E3%81%9F%E3%80%82%20%E3%83%98%E3%83%83%E3%83%80%E3%83%BC%E6%83%85%E5%A0%B1%E3%82%92%E8%BC%89%E3%81%9B%E3%81%9F%E5%A0%B4%E5%90%88%E3%80%81%E7%94%BB%E5%83%8F%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AB%E5%90%88%E3%82%8F%E3%81%9B%E3%81%A6%E3%83%98%E3%83%83%E3%83%80%E3%83%BC%E6%83%85%E5%A0%B1%E3%82%82%E8%BC%89%E3%81%A3%E3%81%A6%E3%81%97%E3%81%BE%E3%81%A3%E3%81%9F%E7%B5%90%E6%9E%9C%E5%A3%8A%E3%82%8C%E3%81%A6%E3%81%84%E3%81%9F%E3%82%88%E3%81%86%E3%81%A7%E3%81%99%E3%80%82))修正後は一連のアップロード～表示の流れを通して再テストを行い、同様の事象が再発しないことを確認します。

最後に、同様の問題を未然に防ぐためには、アップロード処理実装時に**「バイナリデータをそのまま送れているか」「メタデータは適切か」**を常に確認することが重要です。今回のように、フロント/バックエンド/S3の各層でポイントを押さえて対処することで、画像が壊れる不具合は解決できるでしょう。

