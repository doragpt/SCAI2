リポジトリを解析し、循環参照の解消、DBカラムの不一致、バリデーション問題を修正するTypeScriptのコードを提案します。 調査が完了したら、修正コードを共有しますので、少々お待ちください。

Research completed in 9m· 61 件の情報源
1. 循環参照の解消 (benefitTypes ↔ allBenefitTypes)
現在のschema.tsでは、待遇リストの定義においてbenefitTypesオブジェクトと、それを平坦化したallBenefitTypes配列が相互に依存する形になっています。具体的には、allBenefitTypesはbenefitTypesの値を展開して生成され、型定義でBenefitType = typeof allBenefitTypes[number]として参照しています。一方でbenefitTypesもas constで定義されているため型推論時にallBenefitTypesに依存してしまい、これが循環参照エラーの原因となります​
GITHUB.COM
​
GITHUB.COM
。 修正案: 循環依存を避けるため、各カテゴリーごとの待遇リストを個別に定義し、それらを用いてbenefitTypesとallBenefitTypesを組み立てます。例えば以下のように修正します:
typescript
コピーする
// schema.ts (待遇リストの定義修正例)
const interviewBenefits = ["見学だけでもOK", "体験入店OK", ...] as const;
const workStyleBenefits = ["自由出勤OK", "週1日〜OK", ...] as const;
const salaryBenefits = ["日給2万円以上", "日給3万円以上", ...] as const;
const bonusBenefits = ["バック率50%以上", "バック率60%以上", ...] as const;
const facilityBenefits = ["送迎あり", "駅チカ", ...] as const;
const requirementsBenefits = ["未経験大歓迎", "経験者優遇", ...] as const;

export const benefitTypes = {
  interview: interviewBenefits,
  workStyle: workStyleBenefits,
  salary: salaryBenefits,
  bonus: bonusBenefits,
  facility: facilityBenefits,
  requirements: requirementsBenefits,
} as const;

export const allBenefitTypes = [
  ...interviewBenefits,
  ...workStyleBenefits,
  ...salaryBenefits,
  ...bonusBenefits,
  ...facilityBenefits,
  ...requirementsBenefits,
] as const;

export type BenefitType = (typeof allBenefitTypes)[number];
export type BenefitCategory = keyof typeof benefitTypes;
このように各配列を個別に宣言してからオブジェクトと総合配列を作成することで、benefitTypesの定義時にallBenefitTypesへ直接依存することを避けられます。また型定義BenefitTypeやBenefitCategoryも同一ファイル内で循環せずに解決できます。修正後もallBenefitTypesは全待遇のユニオン型として利用でき、Zodスキーマでの列挙型定義にも問題なく適用できます（例: z.enum(allBenefitTypes)）​
GITHUB.COM
​
GITHUB.COM
。
2. テーブルカラム名の不整合修正 (selected_benefits → benefits)
コード上で参照しているカラム名とデータベース実テーブルのカラム名が一致していないため、保存処理でエラーが発生しています。具体的には、Jobsテーブルにおいて実際には福利厚生・待遇情報を保存するカラムはbenefitsですが、コード上どこかでselected_benefitsという名称を参照している可能性があります。スキーマ定義を見ると、Jobsテーブルにはbenefitsカラム（JSON配列）が定義されており​
GITHUB.COM
、フロントエンドのフォームデータでもbenefitsというフィールド名が使われています​
GITHUB.COM
。一方、データベースにはselected_benefitsというカラムは存在しません。 修正案: コード全体を見直し、selected_benefitsというフィールド名を 廃止 して、一貫して benefits を用いるようにします。例えば、求人作成APIにリクエストを送る部分や、フォームのデータ構築部分で誤ってselectedBenefits（キャメルケース）やselected_benefits（スネークケース）を使っている箇所があれば、これをbenefitsに統一します。また、サーバー側の処理でもreq.bodyから取り出す際にはreq.body.benefitsを参照するべきです（実際、サーバー側ではZodスキーマでbenefits配列をパースしています​
GITHUB.COM
）。 データベースの整合: 既にDBにbenefitsカラムが存在しselected_benefitsが無い場合はコード修正のみで問題は解消します。仮に過去のマイグレーション等でselected_benefitsカラムを誤って作成していた場合には、マイグレーションを用いてそのカラムを削除するか、正しいbenefitsカラムにリネームしてください。最終的に、アプリケーションコードとデータベーススキーマのカラム名が一致するようにします。これにより、「カラムが存在しない」エラーは解消されます。
3. locationカラムのNOT NULL制約違反の対策
求人情報保存時にlocation（勤務地）フィールドでNOT NULL制約違反が発生しているのは、フォームから空の値（nullもしくは空文字）が送信されている可能性があります。コードを見ると、Jobsテーブルのlocationカラムはtext .notNull()で定義されておりNULLを許しません​
GITHUB.COM
。また求人のZodスキーマでもlocation: z.string().min(1, "所在地を入力してください")と必須入力になっています​
GITHUB.COM
。それにも関わらずNULL違反が起きるのは、フロント側でlocationが正しく入力・設定されていないまま保存処理が走っている可能性があります。 原因と対策:
ユーザー登録時の所在地未設定: 店舗ユーザー（求人投稿者）のプロフィールlocationが設定されていない場合、求人フォームでデフォルト値が空文字列になる可能性があります。実際にはユーザー登録時に都道府県を選択させ、ユーザーテーブルのlocationにNOT NULLで保存していますが、何らかの理由でuser.locationが空の場合、フォームのdefaultValuesでlocation: ""となり、そのままではバリデーションエラーになります​
GITHUB.COM
。これに対するガードはサーバー側のミューテーションでも行われており、user?.locationが無ければエラーを投げる実装になっています​
GITHUB.COM
。しかし、このエラーはフォーム上でフィールドのエラーメッセージとして表示されず、結果的に保存ボタンが無効化される一因にもなっています。
フォームで所在地入力をスキップしている: 現在の実装では、求人フォームのlocationはユーザーの登録所在地を自動セットし、フォーム上で直接編集しない設計のようです（businessNameと同様に編集不可）​
GITHUB.COM
。そのため、本来ユーザーがプロフィールで所在地を設定済みであればフォームでlocationが空になることはありません。しかし、もし求人ごとに異なる勤務地を指定したい要件があるなら、フォームに都道府県選択のフィールドを追加し、jobSchemaのlocationもz.enum(prefectures)のように変更して選択を強制する方法が考えられます。現状の要件では「店舗の所在地＝求人の所在地」として扱っているようなので、基本はユーザープロフィール側でNULLを防ぐべきです。
修正案:
ユーザープロフィールの所在地必須を徹底: ユーザー登録やプロフィール編集のバリデーションでlocationを必須にし、NULLや空白を許容しないようにします（すでにユーザースキーマでは都道府県をenum選択させています​
GITHUB.COM
​
GITHUB.COM
）。万一プロフィール未設定のユーザーが求人フォームを開こうとした場合は、フォームを表示せず「プロフィールの所在地を設定してください」という案内を出すか、保存時にonErrorで出しているトーストエラーだけでなくフォーム上にも明示的なエラー表示を行うとよいでしょう。
求人フォームでのデフォルト値確認とフォールバック: useFormのdefaultValuesでlocation: user?.location || ""としていますが​
GITHUB.COM
、ここを空文字ではなく安全なデフォルトを設定することも検討します。ただし、「所在地未設定」の状態自体を無くす方向で対処する方が健全です（無理にデフォルトで「未設定」などを入れると不整合が生じるため）。したがって、基本は上記1の対策でユーザーに所在地を設定させるのが筋です。
（オプション）勤務地を選択可能にする: 将来的に店舗所在地とは別に求人ごとに勤務地を設定できるようにする場合、フォームに都道府県選択フィールドを追加します。その際はjobSchema.locationをz.enum(prefectures, { required_error: "都道府県を選択してください" })に変更し​
GITHUB.COM
、デフォルト値もuser.locationで初期選択するようにします。こうすればフォーム上でユーザーが必ず何らかの都道府県を選ぶことになり、NULL違反も起きません。
以上の対策により、locationがNULLで保存されようとするケースを排除し、NOT NULL制約違反エラーを解消します。特にユーザープロフィールの所在地が必ず設定されていることを保証する運用・実装にするのが重要です。
4. 求人フォームの送信ボタン無効化とバリデーション表示の修正
現状では、「保存する」ボタンが常に押せない状態になる、あるいは押せてもバリデーションエラーの内容がユーザーに伝わりにくいという問題が指摘されています。コードを確認すると、保存ボタンのdisabledプロパティはミューテーション実行中にのみtrueとなるよう意図されていますが​
GITHUB.COM
、実際にはフォーム未入力のエラーがあってもユーザー側でそれと認識できない形でボタンが非活性化している可能性があります。 考えられる原因:
React Hook Formのバリデーション結果によっては、送信ハンドラが呼ばれずボタンも反応しないため、ユーザーから見ると「押せない」ように感じられます。デフォルトでは、react-hook-formはバリデーションエラーがあるとhandleSubmit内のonSubmit関数を実行しません。このとき各フィールドにはエラーメッセージが設定されますが、現在の実装では<FormMessage />を配置しているとはいえ、エラー表示のタイミングが遅いためユーザーが気づきにくい可能性があります。例えば、最初の「詳細情報」タブで必須項目を空のまま「給与・待遇」タブに移動してしまうと、エラーが表示されないまま保存ボタンを押すことになります。このときcatchPhraseやdescriptionに未入力エラーが残っていると、送信ボタンを押しても反応しない（内部的にはバリデーションNGでonSubmitが実行されない）ため、ユーザーには「押せないように見える」状況になります。
ミューテーションのisPendingの使い方にも注意が必要です。useMutationには通常isLoadingプロパティが存在し、送信処理中かどうかを示します。コードではconst { mutate, isPending } = useMutation(...)としていますが、isPendingはおそらくisLoadingのエイリアスもしくはカスタムフック由来でしょう​
GITHUB.COM
。ここで意図しない真偽値になっていないか確認し、通常はisLoadingを使うようにします。送信中でないのにisPendingがtrueになってしまうと常にボタンがdisabledになりますので、もしバグがあるようなら修正します。
修正案:
バリデーションエラーの即時表示: フォームのエラーメッセージがユーザーに見えるように、React Hook Formの設定を調整します。例えば、useFormにmode: 'onBlur'またはmode: 'onChange'を指定し、ユーザーがフィールドからフォーカスを外した時点でエラーを表示するようにします。これにより、必須項目を空のまま次のタブに移った場合でも、直前にいたタブ内の未入力項目にエラー表示が出てユーザーが気づけます。または、タブを切り替えるハンドラ内でform.trigger(["businessName", "location", "catchPhrase", ...])のように明示的に現在のタブのフィールドを検証し、エラーがあればタブ移動を止める／エラー表示する対応も考えられます。
保存ボタンの無効化ロジック見直し: 送信ボタンは基本常に押せるようにし、押下時に内部でバリデーション→エラー表示→成功時のみ送信、という流れにします。現行コードではdisabled={isPending}としており、送信中のみ無効化しています​
GITHUB.COM
。この部分はそのままで問題ありませんが、もし意図せず常時isPendingがtrueになってしまう不具合があるなら修正します（たとえばuseMutationの戻り値プロパティ名の誤りで常にundefined扱いになっているなど）。React Hook FormはformState.isValidプロパティも提供しますが、これでボタンを制御するより、ユーザーが押したときにエラー箇所をハイライトする方が親切です。従って、「必須項目の入力漏れがある場合はボタンを非活性にする」というロジックは入れず、ユーザーに押させてからエラーを知らせる形で構いません。
エラー内容のユーザーへの提示: 現在、サーバー側でのバリデーション失敗（Zodエラー）時にはHTTP 400でmessage: '入力内容に誤りがあります'というレスポンスを返し、フロントではそれを受けて汎用的なエラートーストを表示しています​
GITHUB.COM
​
GITHUB.COM
。しかしどのフィールドに問題があるかは詳細に伝わっていません。上記1の対応でクライアントサイドで大半のエラーは検出・表示できますが、念のためサーバーから返るエラーのdetails（Zodエラーの詳細メッセージ）も活用し、トーストではなく各フィールドのエラー表示に反映させることも検討できます。例えば、error.detailsにフィールドごとのメッセージが含まれるなら、それをform.setErrorで対応するフィールドにセットする処理をonErrorハンドラで行う、という実装です。これにより、サーバーサイドバリデーションエラー時でもユーザーにどの項目が不正か具体的に示せます。
以上の修正により、ユーザーは求人フォームで入力漏れや不備がある場合にすぐに認識でき、適切に修正できます。また保存ボタンが押せないと感じる状況も改善されます。例えば、キャッチコピーを入力せずに保存しようとした場合、「キャッチコピーを入力してください」というエラーがフォーム上に表示され、ボタンが効かない原因が明確になります​
GITHUB.COM
。送信中でない限りボタンは押下可能とし、押した後のレスポンスも含めてエラーハンドリングを行うことで、UXの向上とバグの解消が期待できます。 参考: 修正後の期待される動作
必須フィールドを空のまま次のステップに移動しようとすると、そのフィールド下にエラーメッセージが表示される。
保存ボタンは常時アクティブだが、未入力項目があれば押下時にフォーム上にエラーが表示され、データ送信は行われない。
locationフィールドがユーザー情報に基づき自動セットされ、未設定の場合はフォーム送信前にエラーメッセージや通知でユーザーに所在地設定を促す（NULLがそのまま送られることを防止）。
「保存しました」の成功トーストや、「入力内容に誤りがあります」のエラートーストが表示された場合でも、具体的な入力ミス箇所がフォーム上で強調表示される。
これらの修正によって、提示されていた4つの問題点は解消される見込みです。コード修正後は型定義の循環エラーがなくなり​
GITHUB.COM
、データ保存時のカラム不整合エラーやNOT NULL違反も発生せず​
GITHUB.COM
​
GITHUB.COM
、フォームの使い勝手も大きく向上するでしょう。必要に応じてマイグレーション（例えば不要なカラムの削除や型の変更）も適用し、データベースとアプリの整合性を確実にしてください。各修正箇所の整合性をテストし、問題が再発しないことを確認します。