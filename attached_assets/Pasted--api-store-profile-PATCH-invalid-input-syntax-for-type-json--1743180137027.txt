ありがとうございます。では、`/api/store/profile` のPATCHエンドポイントで発生している `invalid input syntax for type json` エラーについて、GitHubリポジトリ SCAI2 の `routes/store.ts`、`SpecialOfferEditor.tsx`、`job-form-tabs.tsx` のコード構造を調査し、`special_offers` データ構造と PostgreSQL の JSONB カラム形式との不整合が起きている原因を特定します。

完了後に、原因の箇所と修正方法についても詳しくご報告いたします。しばらくお待ちください。

**特典リスト（special_offers）の構造**: 本リポジトリでは店舗プロフィールの`special_offers`をPostgreSQLのJSONB型カラムとして定義しています ([SCAI2/shared/schema.ts at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/shared/schema.ts#:~:text=special_offers%3A%20jsonb%28))。JSONBは任意のJSON構造を格納できるため、配列形式の特典リスト（各特典は`id`, `title`, `description`, `icon`, `backgroundColor`, `textColor`, `order`などのフィールドを持つオブジェクト）自体はデータ型として問題ありません。各フィールド値も文字列・数値・ブール値・配列といったJSONで有効な型のみで構成されており、構造上はJSONBに準拠しています。例えばスキーマ上、`special_offers`は`SpecialOffer`オブジェクトの配列として定義され、デフォルト値は空配列です ([SCAI2/shared/schema.ts at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/shared/schema.ts#:~:text=special_offers%3A%20jsonb%28)) ([SCAI2/shared/schema.ts at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/shared/schema.ts#:~:text=special_offers%3A%20z))。したがって**特典リストの形式そのものはPostgreSQLのJSONBに適合**しています。

**無効な値（NaN・undefined・nullなど）の混入チェック**: クライアント側では`SpecialOfferEditor`コンポーネントと`normalizeSpecialOffers`関数により、特典データを一旦JSのオブジェクト配列に整形してからJSON文字列に変換し、フォームの状態管理をしています ([SCAI2/client/src/components/store/SpecialOfferEditor.tsx at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/client/src/components/store/SpecialOfferEditor.tsx#:~:text=const%20updateFields%20%3D%20%28newFields%3A%20SpecialOffer,))。送信直前に`prepareFormData`内で`special_offers`を確実に配列化・正規化する処理が実行されます ([SCAI2/client/src/components/job-form-tabs.tsx at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/client/src/components/job-form-tabs.tsx#:~:text=if%20%28Array.isArray%28cleanedData.special_offers%29%29%20)) ([SCAI2/client/src/components/job-form-tabs.tsx at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/client/src/components/job-form-tabs.tsx#:~:text=%2F%2F%20%E6%96%87%E5%AD%97%E5%88%97%E3%81%AE%E5%A0%B4%E5%90%88%E3%81%AF%E3%80%81%E3%83%91%E3%83%BC%E3%82%B9%E3%81%97%E3%81%A6%E9%85%8D%E5%88%97%E3%81%AB%E5%A4%89%E6%8F%9B))。この中で`normalizeSpecialOffers`関数が各特典オブジェクトを検証・補正しています。 ([SCAI2/client/src/components/job-form-tabs.tsx at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/client/src/components/job-form-tabs.tsx#:~:text=return%20offersArray))に示すように、配列でない値は空配列に置き換え、各要素についても「オブジェクトであること」をフィルタした上で、必須フィールドが文字列か数値かなど型チェックを行い、欠落時にはデフォルト値を設定しています（例えば`id`が空なら新規UUID生成、`title`が未設定なら"特別オファー"、`order`が数値でなければ0を設定等 ([SCAI2/client/src/components/job-form-tabs.tsx at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/client/src/components/job-form-tabs.tsx#:~:text=%2F%2F%20%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA%E6%A7%8B%E9%80%A0%E3%81%AE%E7%A2%BA%E8%AA%8D%E3%81%A8%E6%A8%99%E6%BA%96%E5%8C%96)) ([SCAI2/client/src/components/job-form-tabs.tsx at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/client/src/components/job-form-tabs.tsx#:~:text=title%3A%20typeof%20offer,%E7%89%B9%E5%88%A5%E3%82%AA%E3%83%95%E3%82%A1%E3%83%BC))）。この過程で**`undefined`はオブジェクトのプロパティとして残らず**、`NaN`や`Infinity`といった非数値も`typeof === 'number'`判定では真とみなされますが、これらはJSON.stringify時に自動的に`null`に変換されるため（JSONでは非有限数は`null`としてシリアライズされます）、**特殊な数値が混入する可能性は低く**、仮に混入しても`null`として処理されサーバ側バリデーションで弾かれるでしょう。実際サーバ側のZodスキーマでは`special_offers`を各要素が必要フィールドを持つオブジェクト配列として定義しており ([SCAI2/shared/schema.ts at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/shared/schema.ts#:~:text=special_offers%3A%20z))、これに適合しない場合（例：型違い、`order`がnullになる等）は`ZodError`がthrowされます ([SCAI2/server/routes/store.ts at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/server/routes/store.ts#:~:text=const%20validatedData%20%3D%20storeProfileSchema.parse%28)) ([SCAI2/server/routes/store.ts at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/server/routes/store.ts#:~:text=%2F%2F%20%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0%E7%89%B9%E5%85%B8))。以上より、**特典データにNaNやundefinedが紛れ込むリスクは、クライアントの正規化処理とサーバのスキーマ検証によって最小化**されています。

**クライアントとサーバのデータ処理整合性**: クライアント側`SpecialOfferEditor`では内部で特典リストを配列として保持しつつ、親コンポーネントとのやりとりにはJSON文字列を使っています ([SCAI2/client/src/components/store/SpecialOfferEditor.tsx at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/client/src/components/store/SpecialOfferEditor.tsx#:~:text=const%20updateFields%20%3D%20%28newFields%3A%20SpecialOffer,))。そのためフォーム状態`data.special_offers`は編集中に一時的に文字列型になる可能性があります。これを受けて`prepareFormData`関数では、`special_offers`が**配列型か文字列型かをチェックし**、文字列であれば`JSON.parse`で配列に変換する処理を入れています ([SCAI2/client/src/components/job-form-tabs.tsx at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/client/src/components/job-form-tabs.tsx#:~:text=else%20if%20%28typeof%20cleanedData,)) ([SCAI2/client/src/components/job-form-tabs.tsx at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/client/src/components/job-form-tabs.tsx#:~:text=const%20parsedOffers%20%3D%20JSON))。最終的に`cleanedData.special_offers`は常に配列（または変換失敗時は空配列）となり ([SCAI2/client/src/components/job-form-tabs.tsx at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/client/src/components/job-form-tabs.tsx#:~:text=cleanedData,)) ([SCAI2/client/src/components/job-form-tabs.tsx at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/client/src/components/job-form-tabs.tsx#:~:text=%2F%2F%20%E4%BB%96%E3%81%AE%E5%9E%8B%E3%81%AE%E5%A0%B4%E5%90%88%E3%81%AF%E7%A9%BA%E9%85%8D%E5%88%97%E3%81%AB%E8%A8%AD%E5%AE%9A))、その後`normalizeSpecialOffers`で各特典オブジェクトの不要なフィールドを削除・統一します（この処理によりクライアントのみで使われていた`type`, `isActive`, `isLimited`, `targetAudience`といったフィールドはサーバ送信前に全て揃いますが、Zodスキーマ上定義されていないフィールドはパース時に無視され結果には含まれません※）。つまり**クライアント⇒サーバ送信時点での`special_offers`は「余計なフィールド込みのオブジェクト配列」ですが、サーバ側でZodパースすることで必要項目だけを抜き出し**（未定義のキーはZodによりデフォルトで削除されます）、**最終的にDBには必要フィールド（idやtitle等）だけが格納**されます。この一連の流れにより、特典データの整合性は概ね保たれており、UI用フィールドが混入してもDBスキーマ違反にはなりません。※必要であればZodスキーマを`strict()`にして未知フィールド存在時にエラーとすることもできますが、現状でも実害はありません。

**エラーの原因分析**: `PATCH /api/store/profile`呼び出しで発生している「`invalid input syntax for type json`」というPostgreSQLエラーは、送信されたJSONデータそのものというより**データベースに渡される際の形式不備**が原因と考えられます。クライアント・サーバ双方のロジックを見る限り、`special_offers`は確実にJSON配列へと正規化・バリデーションされており、JSON文字列として不正（例えば対応するクォートが欠けている、制御文字がエスケープされていない等）のデータが混入する可能性は低そうです。そこで注目すべきは、**ORMレイヤ（Drizzle ORM）によるJSONBパラメータの扱い**です。実はDrizzle ORMには**JSONB型の値を二重に文字列化してしまう不具合**が報告されており、これに起因するエラーと符号します ([[BUG]: jsonb type on postgres implement incorrectly · Issue #1511 · drizzle-team/drizzle-orm · GitHub](https://github.com/drizzle-team/drizzle-orm/issues/1511#:~:text=Drizzle%3A%20%60%2410%20%3D%20%27,team%20can%20address%20this%20bug))。具体的には、ORMが内部で既にシリアライズ済みのJSON文字列にさらにクォートを付与してSQLパラメータとしようとするため、PostgreSQL側から見ると余分な引用符を含んだ無効なJSONリテラルになってしまうのです。例えばある報告では、`{"foo": "bar"}`というJSONを挿入しようとした際に、実際のクエリパラメータが`$1 = '"{\"foo\":\"bar\"}"'`のように二重引用符で囲まれた文字列として送信されていました ([[BUG]: jsonb type on postgres implement incorrectly · Issue #1511 · drizzle-team/drizzle-orm · GitHub](https://github.com/drizzle-team/drizzle-orm/issues/1511#:~:text=Drizzle%3A%20%60%2410%20%3D%20%27,team%20can%20address%20this%20bug))。当然これは正しいJSONではないため、PostgreSQLはパースできずにエラー`22P02`（JSONの構文エラー）を発生させます。今回の`special_offers`でも同様に、**正しく構造化されたJSオブジェクト配列が、送信時に二重にエンコードされた結果、PostgreSQLで「無効なJSON文字列」と判断された**可能性が高いと考えられます。

**構造上の不備・エッジケースと修正提案**: 上記の推察が正しければ、アプリケーションコードの主要ロジック（特典データの整形・検証）自体は概ね正しく、問題は**ORMのJSONBパラメータ取り扱いの不備**にあります。したがって修正策としては、以下のようなアプローチが考えられます。

- **ORMのアップデートまたはワークアラウンド**: Drizzle ORMの最新版でこのJSONB二重エンコードの不具合が修正されている場合はアップデートが最善です。もし現行バージョンで対処する必要がある場合、カスタム型を定義して内部の文字列化処理をスキップする方法が有効とされています ([[BUG]: jsonb type on postgres implement incorrectly · Issue #1511 · drizzle-team/drizzle-orm · GitHub](https://github.com/drizzle-team/drizzle-orm/issues/1511#:~:text=I%20had%20a%20similar%20issue,stringify%20is%20skipped)) ([[BUG]: jsonb type on postgres implement incorrectly · Issue #1511 · drizzle-team/drizzle-orm · GitHub](https://github.com/drizzle-team/drizzle-orm/issues/1511#:~:text=I%20did%20some%20more%20checking,team%20can%20address%20this%20bug))。具体的には、`customType`を用いて`dataType()`で`'jsonb'`を返しつつ、`toDriver(value)`で`value`（JSのオブジェクト/配列）をそのまま返すような型を定義し、スキーマ定義で`special_offers: customJsonb<SpecialOffer[]>('special_offers')`のように差し替えます。こうすることでDrizzleは値をそのまま渡し、内部で余計なJSON.stringifyを行わなくなります。実際この方法で、クエリパラメータが正しく`{"foo":"bar"}`の形式になり問題が解消したとの報告があります ([[BUG]: jsonb type on postgres implement incorrectly · Issue #1511 · drizzle-team/drizzle-orm · GitHub](https://github.com/drizzle-team/drizzle-orm/issues/1511#:~:text=I%20did%20some%20more%20checking,team%20can%20address%20this%20bug))。

- **直接的なJSON文字列の扱い**: 一時的な措置として、特殊なSQLクエリを用いて正しいJSONリテラルを渡す方法も考えられます。例えば、Drizzleの`sql`タグを使い、`special_offers: sql`${JSON.stringify(fullUpdateData.special_offers)}::jsonb``のようにJSON文字列リテラルに明示的に`::jsonb`キャストを付けて更新することが考えられます。これにより、二重引用符ではなく純粋なJSON文字列がSQLに埋め込まれるため、PostgreSQL側で正しくパースされる可能性があります。ただしこの方法はORMの型安全性を損なう恐れがあり、文字列のエスケープにも注意が必要です。可能であればORMの提供する公式手段（上記カスタム型など）で対処する方が望ましいでしょう。

- **ログ出力と検証の強化**: エラー発生時には既にサーバ側でエラーメッセージやリクエストボディをログに記録していますが ([SCAI2/server/routes/store.ts at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/server/routes/store.ts#:~:text=%7D%20catch%20%28error%29%20)) ([SCAI2/server/routes/store.ts at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/server/routes/store.ts#:~:text=userId%3A%20req))、さらなるデバッグのために**実際にDBに渡しているパラメータの内容**を確認する施策も有効です。たとえば、PostgreSQLの`log_statement`や`log_parameters`設定を有効にしてクエリとバインド値をログに出すか、コード上で`db.update()`実行前に`JSON.stringify(fullUpdateData.special_offers)`をログ出力しておくと、値が想定通りの形式か（二重にエンコードされていないか）確認できます。現在のコードでも`log('info', 'SQLクエリ実行準備中', {...})`といったログがありますが ([SCAI2/server/routes/store.ts at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/server/routes/store.ts#:~:text=log%28%27info%27%2C%20%27SQL%E3%82%AF%E3%82%A8%E3%83%AA%E5%AE%9F%E8%A1%8C%E6%BA%96%E5%82%99%E4%B8%AD%27%2C%20))、ここに`updateData.special_offers`や`validatedData.special_offers`を追加しておけば、実運用中のログで問題のデータ形式を追跡できるでしょう。

- **その他のエッジケース**: 構造上大きな問題は見当たりませんが、強いて挙げるならクライアントとサーバ間で特典オブジェクトのフィールド不一致がある点です（前述の`type`や`isActive`等はサーバでは保持されない）。設計上不要だから保存していないだけで動作上は問題ありませんが、もし将来的に必要になる場合はスキーマにフィールド追加するか、逆にUI側でこれらフィールドを外してから送信する対応も検討できます。また、`order`フィールドについては現状数値とみなせるものはそのまま通しているため、理論上`Infinity`や`NaN`も通過しかねません。現実的には発生しにくいものの、万全を期すなら`Number.isFinite(offer.order)`でチェックするなどの微調整も考えられます。

以上の対策により、`special_offers`更新時のJSONパースエラーは解決できる見込みです。また、サーバ側では既に例外発生時にHTTP 500とともに`sqlError`フィールドで詳細メッセージを返すよう実装されています ([SCAI2/server/routes/store.ts at main · doragpt/SCAI2 · GitHub](https://github.com/doragpt/SCAI2/blob/main/server/routes/store.ts#:~:text=if%20%28error.message.includes%28%27relation%27%29%20,includes%28%27syntax%27%29%29))。原因究明のためにはこのメッセージ（今回であれば「invalid input syntax for type json」）をクライアント側コンソールで確認したり、適宜スタックトレース付きでログに記録することも有効です。総合すると、**特典データの内容・構造そのものよりも、DB挿入時の形式変換に問題があった**と考えられるため、上記のようにORMの扱いを修正・補強することで問題に対処できます。

**参考**: Drizzle ORMのIssueコメントでは、問題のJSONB二重エンコードについて具体的なログ例と回避策が議論されています ([[BUG]: jsonb type on postgres implement incorrectly · Issue #1511 · drizzle-team/drizzle-orm · GitHub](https://github.com/drizzle-team/drizzle-orm/issues/1511#:~:text=Drizzle%3A%20%60%2410%20%3D%20%27,team%20can%20address%20this%20bug)) ([[BUG]: jsonb type on postgres implement incorrectly · Issue #1511 · drizzle-team/drizzle-orm · GitHub](https://github.com/drizzle-team/drizzle-orm/issues/1511#:~:text=I%20did%20some%20more%20checking,team%20can%20address%20this%20bug))。必要に応じて参照してください。

